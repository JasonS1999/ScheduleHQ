rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // Helper function to check manager role
    // Uses exists() first to avoid errors when document doesn't exist
    function isManager() {
      return request.auth != null && 
             exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
             get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == "manager";
    }
    
    // Helper function to check if user owns this employee record
    function isOwnEmployee(email) {
      return request.auth != null && request.auth.token.email == email;
    }
    
    // Users collection - MUST come first so managers can create their own profile
    // Any authenticated user can create/update their OWN user document
    // This allows first-time manager setup
    match /users/{uid} {
      allow read: if request.auth != null && (request.auth.uid == uid || isManager());
      allow create: if request.auth != null && request.auth.uid == uid;
      allow update: if request.auth != null && (request.auth.uid == uid || isManager());
    }
    
    // Manager Settings - each manager can only access their own settings
    match /managerSettings/{uid} {
      allow read, write: if request.auth != null && request.auth.uid == uid && isManager();
    }

    // ============== PER-MANAGER DATA ==============
    // Each manager has their own subcollections for employees, shifts, time-off, etc.
    
    match /managers/{managerUid} {
      // Manager can access their own root document
      allow read, write: if request.auth != null && request.auth.uid == managerUid && isManager();
      
      // Employees subcollection - manager writes, employees read own
      match /employees/{docId} {
        allow read: if request.auth != null && 
                      (request.auth.uid == managerUid || 
                       isOwnEmployee(resource.data.email));
        allow write: if request.auth != null && request.auth.uid == managerUid && isManager();
      }
      
      // Shifts subcollection - manager writes, employees read own shifts
      match /shifts/{docId} {
        allow read: if request.auth != null && 
                      (request.auth.uid == managerUid || 
                       resource.data.employeeUid == request.auth.uid);
        allow write: if request.auth != null && request.auth.uid == managerUid && isManager();
      }
      
      // Published schedules metadata - manager only
      match /publishedSchedules/{docId} {
        allow read, write: if request.auth != null && request.auth.uid == managerUid && isManager();
      }
      
      // Time off entries - manager writes, employees read own
      match /timeOff/{docId} {
        allow read: if request.auth != null && 
                      (request.auth.uid == managerUid || 
                       resource.data.employeeUid == request.auth.uid);
        allow write: if request.auth != null && request.auth.uid == managerUid && isManager();
      }
      
      // Time off requests - employees create own, manager approves/denies
      match /timeOffRequests/{docId} {
        allow read: if request.auth != null && 
                      (request.auth.uid == managerUid || 
                       resource.data.employeeUid == request.auth.uid);
        allow create: if request.auth != null && 
                         request.resource.data.employeeUid == request.auth.uid;
        allow update: if request.auth != null && request.auth.uid == managerUid && isManager();
      }
      
      // Shift runners - manager only
      match /shiftRunners/{docId} {
        allow read, write: if request.auth != null && request.auth.uid == managerUid && isManager();
      }
      
      // Employee availability - manager only
      match /employeeAvailability/{docId} {
        allow read, write: if request.auth != null && request.auth.uid == managerUid && isManager();
      }
      
      // Weekly templates - manager only
      match /weeklyTemplates/{docId} {
        allow read, write: if request.auth != null && request.auth.uid == managerUid && isManager();
      }
      
      // Shift templates - manager only
      match /shiftTemplates/{docId} {
        allow read, write: if request.auth != null && request.auth.uid == managerUid && isManager();
      }
    }

    // ============== LEGACY ROOT COLLECTIONS (keeping for backwards compatibility) ==============
    
    // Employees - managers write, employees read own
    match /employees/{docId} {
      allow read: if request.auth != null && (isManager() || isOwnEmployee(resource.data.email));
      allow write: if isManager();
    }
    
    // Shifts - managers write, employees read own shifts
    match /shifts/{docId} {
      allow read: if request.auth != null && 
                    (isManager() || resource.data.employeeUid == request.auth.uid);
      allow write: if isManager();
    }
    
    // Published schedules metadata - managers only
    match /publishedSchedules/{docId} {
      allow read, write: if isManager();
    }
    
    // Time off entries - managers write, employees read own
    match /timeOff/{docId} {
      allow read: if request.auth != null && (isManager() || 
                     resource.data.employeeUid == request.auth.uid);
      allow write: if isManager();
    }
    
    // Time off requests - employees create own, managers update
    match /timeOffRequests/{docId} {
      allow read: if request.auth != null && (isManager() || 
                     resource.data.employeeEmail == request.auth.token.email ||
                     resource.data.employeeUid == request.auth.uid);
      allow create: if request.auth != null && 
                       request.resource.data.employeeEmail == request.auth.token.email;
      allow update: if isManager();
    }
    
    // PTO Summary - employees read own, managers read/write all
    match /ptoSummary/{uid} {
      allow read: if request.auth != null && (request.auth.uid == uid || isManager());
      allow write: if isManager();
    }
  }
}
