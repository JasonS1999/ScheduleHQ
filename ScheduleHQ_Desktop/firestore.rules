rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // Helper function to check manager role
    // Uses exists() first to avoid errors when document doesn't exist
    function isManager() {
      return request.auth != null && 
             exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
             get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == "manager";
    }
    
    // Helper function to check if user owns this employee record
    function isOwnEmployee(email) {
      return request.auth != null && request.auth.token.email == email;
    }
    
    // Users collection - MUST come first so managers can create their own profile
    // Any authenticated user can create/update their OWN user document
    // This allows first-time manager setup
    match /users/{uid} {
      allow read: if request.auth != null && (request.auth.uid == uid || isManager());
      allow create: if request.auth != null && request.auth.uid == uid;
      allow update: if request.auth != null && (request.auth.uid == uid || isManager());
    }
    
    // Manager Settings - each manager can only access their own settings
    match /managerSettings/{uid} {
      allow read, write: if request.auth != null && request.auth.uid == uid && isManager();
    }
    
    // Global settings - only managers can read/write auth code settings
    // The Cloud Function handles public creation requests
    match /settings/managerAuthCode {
      allow read, write: if isManager();
    }

    // ============== PER-MANAGER DATA ==============
    // Each manager has their own subcollections for employees, shifts, time-off, etc.
    
    match /managers/{managerUid} {
      // Manager can access their own root document
      allow read, write: if request.auth != null && request.auth.uid == managerUid && isManager();
      
      // Employees subcollection - manager writes, employees read own
      match /employees/{docId} {
        allow read: if request.auth != null && 
                      (request.auth.uid == managerUid || 
                       isOwnEmployee(resource.data.email));
        allow write: if request.auth != null && request.auth.uid == managerUid && isManager();
      }
      
      // Shifts subcollection - manager writes, employees read own shifts
      match /shifts/{docId} {
        allow read: if request.auth != null && 
                      (request.auth.uid == managerUid || 
                       resource.data.employeeUid == request.auth.uid);
        allow write: if request.auth != null && request.auth.uid == managerUid && isManager();
      }
      
      // Published schedules metadata - manager only
      match /publishedSchedules/{docId} {
        allow read, write: if request.auth != null && request.auth.uid == managerUid && isManager();
      }
      
      // Month-based schedules subcollection: managers/{managerUid}/schedules/{month}/shifts
      match /schedules/{monthId} {
        allow read: if request.auth != null;
        
        match /shifts/{shiftId} {
          // Managers can read all shifts, employees can read their own
          allow read: if request.auth != null && 
                        (request.auth.uid == managerUid || 
                         resource.data.employeeUid == request.auth.uid);
          allow write: if request.auth != null && request.auth.uid == managerUid && isManager();
        }
      }
      
      // Time off entries - manager writes, employees can create own entries
      // Employees can also update/delete their own PENDING entries
      match /timeOff/{docId} {
        allow read: if request.auth != null && 
                      (request.auth.uid == managerUid || 
                       resource.data.employeeUid == request.auth.uid);
        // Manager can do anything, employee can only create their own entries
        allow create: if request.auth != null && 
                        (request.auth.uid == managerUid || 
                         request.resource.data.employeeUid == request.auth.uid);
        // Manager can update/delete anything, employee can only update/delete their own PENDING entries
        allow update, delete: if request.auth != null && 
                        (request.auth.uid == managerUid || 
                         (resource.data.employeeUid == request.auth.uid && 
                          resource.data.status == 'pending'));
      }
      
      // NOTE: timeOffRequests collection is DEPRECATED - all requests now go to timeOff
      // Keeping rules for backwards compatibility during migration
      match /timeOffRequests/{docId} {
        allow read: if request.auth != null && 
                      (request.auth.uid == managerUid || 
                       resource.data.employeeUid == request.auth.uid);
        allow create: if request.auth != null;
        allow update: if request.auth != null && request.auth.uid == managerUid && isManager();
      }
      
      // Shift runners - manager only
      match /shiftRunners/{docId} {
        allow read, write: if request.auth != null && request.auth.uid == managerUid && isManager();
      }
      
      // Employee availability - manager only
      match /employeeAvailability/{docId} {
        allow read, write: if request.auth != null && request.auth.uid == managerUid && isManager();
      }
      
      // Weekly templates - manager only
      match /weeklyTemplates/{docId} {
        allow read, write: if request.auth != null && request.auth.uid == managerUid && isManager();
      }
      
      // Shift templates - manager only
      match /shiftTemplates/{docId} {
        allow read, write: if request.auth != null && request.auth.uid == managerUid && isManager();
      }
      
      // Schedule notes - manager only
      match /scheduleNotes/{docId} {
        allow read, write: if request.auth != null && request.auth.uid == managerUid && isManager();
      }
    }

    // ============== LEGACY ROOT COLLECTIONS (keeping for backwards compatibility) ==============
    
    // Employees - managers write, employees read own
    match /employees/{docId} {
      allow read: if request.auth != null && (isManager() || isOwnEmployee(resource.data.email));
      allow write: if isManager();
    }
    
    // Shifts - managers write, employees read own shifts
    match /shifts/{docId} {
      allow read: if request.auth != null && 
                    (isManager() || resource.data.employeeUid == request.auth.uid);
      allow write: if isManager();
    }
    
    // Published schedules metadata - managers only
    match /publishedSchedules/{docId} {
      allow read, write: if isManager();
    }
    
    // Time off entries - managers write, employees read own
    match /timeOff/{docId} {
      allow read: if request.auth != null && (isManager() || 
                     resource.data.employeeUid == request.auth.uid);
      allow write: if isManager();
    }
    
    // Time off requests - any authenticated user can create, managers update
    match /timeOffRequests/{docId} {
      allow read: if request.auth != null && (isManager() || 
                     resource.data.employeeEmail == request.auth.token.email ||
                     resource.data.employeeUid == request.auth.uid);
      allow create: if request.auth != null;
      allow update: if isManager();
    }
    
    // PTO Summary - employees read own, managers read/write all
    match /ptoSummary/{uid} {
      allow read: if request.auth != null && (request.auth.uid == uid || isManager());
      allow write: if isManager();
    }
    
    // ============== SCHEDULES COLLECTION ==============
    // Month-based schedule storage: managers/{managerUid}/schedules/{YYYY-MM}/shifts/{shiftId}
    // This is a nested subcollection under managers
    match /schedules/{monthId} {
      allow read, write: if request.auth != null;
      
      match /shifts/{shiftId} {
        allow read: if request.auth != null;
        allow write: if isManager();
      }
    }
  }
}
